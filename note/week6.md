# 【第6週】ブルーベリー本輪読会🫐🫐<br />(2022-06-18)

[![hackmd-github-sync-badge](https://hackmd.io/M8hMeimwQQ6VsRQCglXjrQ/badge)](https://hackmd.io/M8hMeimwQQ6VsRQCglXjrQ)


###### tags: `ブルーベリー本`

- [開催概要](https://hackmd.io/1kCgi6_tSGukG0KZrqDLvA)
- [ブルーベリー本輪読会ノートまとめ](https://hackmd.io/Ih6bdReuR3eQpYkGaCx8pg)
- [プロを目指す人のためのTypeScript入門-サポートページ](https://gihyo.jp/book/2022/978-4-297-12747-3/support)（正誤表・サンプルコードのダウンロードページ）
- [Playground](https://www.typescriptlang.org/play)

---
## 2022-06-18（土）
### タイムスケジュール
- 雑談(5min) ~9:05
- 輪読(40min) ~9:45
- 前半の記入(5min) ~9:50
- 休憩(10min) ~10:00
- 輪読(45min) 前半での疑問の解消含む ~10:45
- まとめ(15min) ~ 11:00 （「わからなかったこと疑問」→「気づき」→「振り返り」の順で）

### 進行係

- 前半
    - @haruguchi-yuma
- 後半
    - @SatoshiHaramura

### ドライバー

- 前半
    - @いっしー
- 後半
    - @Saki

### 読んだところ

- p.75 「3.1.2 オブジェクトリテラル(1)基本的な構文」 から

### 次回

- p.85 「3.2 オブジェクトの型」

### 自由に使う共有スペース
p.84のコード載せておきます〜
```js
const foo = { obj: //ここは別
             { num: 1234 }, //ここは同じ
             age: 20
             };
const bar = { ...foo }; 
console.log("foo");
console.log(foo);

console.log("bar");
console.log(bar);
bar.obj.num = 0; //=>ネストしてるのでfooもbarも変わる
console.log(foo.obj.num); // 0と表示される

foo.age = 30 //=>ネストしてないのでbarは変わらない

console.log(foo);
console.log(bar);
console.log(foo.obj === bar.obj);
console.log(foo === bar);
```
### わからなかったこと・疑問など

- p.70のコラム8は、「オブジェクトの中身はいくらでも変更できるけど、`user`という変数自体を宣言&代入し直すのはエラーになるよ」ってことが言いたいのですかね??🤔
    - 代入し直すのがエラーになるのはそうです。変数自体は再宣言できないので、これは `const` とは関係ありません。あとで図で説明します。https://discord.com/channels/715806612824260640/974823180504031242/987516720317096006

- プロパティ名と変数名が同じ時に省略できる書き方は分かりづらい気がする（特に省略するものとしないものが混ざっている場合）けど、省略する書き方の方が推奨されるのかな？
    - めちゃくちゃ便利だと思って使いまくってました...。というかこれがないとやっていけない :face_with_rolling_eyes: ちなみにこの機能は Ruby にも入りました。
        - 確かに他と記法が違うことによってべたがきではなく変数であることがより強調される感じもするから慣れたらパッと理解しやすくなるのかもしれない...という気がしてきました
            - `{ name: name, age: 20, place: place }` とか特に、20が `""` で囲われていないから一瞬変数感がでてしまうというか、nameやplaceと同列な感じがしちゃうから、省略記法のほうがわかりやすいのかも

```javascript=
// こういう感じで混ざってると理解にちょっと負担がかかる感じする
const user = {
        name,
        age: 20,
        place,
        url,
        nickname: "hoge"
    }

//こう書いてある方が全てが対照的な感じで個人的には読みやすい...
const user = {
        name: name,
        age: 20,
        place: place,
        url: url,
        nickname: "hoge"
    }
```
 

- `const obj = { 1: 'foo'}`　はブラケットでアクセスするとき`obj['1']`だけど、プロパティの型はnumberかstringかどっちだろう？
    - `{ "1": "foo" }` と同じなので string ですね。`{ name: "John Doe" }` が `{ "name": "John Doe" }` と書けることを考えると分かりやすいと思います。
    - なるほど！プロパティ名は~~number~~数値リテラルで書いても識別子で書いてもstring型と思えばいいですね。
        - `1:` これは number に見えるけど number ではないです。なぜなら JavaScript のオブジェクトで key として有効なのは string と Symbol だけだからです。number でプロパティアクセスできるのは暗黙的な型変換が行われているのかもしれません。
```javascript=
const obj = {
  1: 'foo' //{ 1: string;}
}

const numberOne: number = 1
const one = 1

console.log(obj[numberOne]) // ダメだった！
console.log(obj[one]);  // いけた！　🤔　
```

- これも暗黙的な型変換が行われているのかも

```typescript=
console.log(Object.keys({ [1]: "foo" })); //=> ["1"]
```

- スプレッド構文のエラーは、JavaScriptだととくにエラーは出ないということでしょうか??
    - はいそうです。TypeScript の好み?というかよきに計らってくれてエラーになっています。

- 3.1.6の挙動かなりややこしいと思うのですが、現場では、そもそも違う変数に入れたりコピーしたりしないで別のオブジェクトを作成するのでしょうか？
    - えーーーどうだろうーーー。ぱっと回答できなさそうなのですが、ネストするようなオブジェクトをそもそも避けているのかもしれません。でもこれ JavaScript (TypeScript) に限った話ではないので、他のプログラミング言語でもそうな気がします。
    
### 各自の疑問点や気づき、学んだこと

- @mami-inuzuka 
    - `[]` を使うとプロパティに動的にアクセスすることができる
        - 式でプロパティ名を決めることができる
        - `messages[num >= 0? : "good" : "bad"]`
    - スプレッド構文でオブジェクトをコピーする場合、ネストされたオブジェクトはコピーされない。（同じオブジェクトが参照され続ける）
        - 変数が参照であることを頭に入れておけば大丈夫！
    

- @cafedomancer 
    - (だれか代わりに読んでください :pray:)
    - `{ ...{ foo: 123 }, foo: -9999 }` は 🙆 だけど `{ foo: -9999, ...{ foo: 123 } }` は 🙅
    - object copying には shallow copy と deep copy がある。spread 構文で行われるのは shallow copy。ブラウザ JavaScript では `window.structuredClone` で deep copy できるらしい？ Node.js では lodash？

- @haruguchi
    - `[]`が動的という意味がよくわからなかったけど、`[]`には式が書けるのでその評価結果によって動的に決めることができるということを知って納得した！
    - オブジェクトのコピー（展開）の前に重複するプロパティ名を置くとTSが気を効かしてエラーにしてくれる
    - ネストしたオブジェクトのコピーは標準的な方法はない。注釈に`structuredClone`というのがあると書いてあって気になる。
    - 変数→値　という図が分かりやすかった
        - この考え方は MIT OpenCourseWare の Python の授業で学びました！
- @Saki
    - オブジェクトの最後のプロパティにカンマをつけられるようになった✨
      - 公式:[末尾のカンマ \- JavaScript \| MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Trailing_commas)
      - カンマつけ忘れてエラーになることよくあったので、使いたい!
      - git の diffも1行だけになって見やすいし、良いことづくめな感じがしたので自作サービスのprettierの設定で取り入れたいと思った
  - p.76:オブジェクトを`プロパティ名:変数名`と書く時に名前が同じ場合、`name,`というように省略して書ける
      - 便利だけど慣れないうちは何をやっているか混乱しそう。なので、見かけたら思い出して読めるようにしておきたい
  - 動的 = プログラムの中での計算によって初めて決まる
  - ブラケットの中には式が書ける。ブラケットとは`式1[式2]`の`[]`内のことを言ってる
  - スプレッド構文:`...obj1`で、obj1の中身をコピーして持ってこれる
      - コピー元とコピー先でプロパティ名が同じだったら、コピー先の方を採用する。上書きするイメージ
      - 以下のように書くと、TypeScriptがコンパイルエラーを出してくれる(JSだととくに出さない)。「どうせ`obj1`の`foo:123`で上書きされるから、ここに書いても意味がないよ〜」と教えてくれるイメージ。
      ```js
      const obj2 = {
        foo: -9999,
        ...obj1 //=>エラー
      }
      ```
  - コラム8の梅本さんのご解説
      - https://discord.com/channels/715806612824260640/974823180504031242/987516720317096006
      - オブジェクトに`user`という"名前をつけている"
      - `user.name = "Tanaka"`や`user.age = 25`などは、`name`や`age`の参照先を変えているので、問題(エラー)にならない
      - あくまで`user`の参照先を変えようとすると、`const`はエラーになる。(`let`はエラーにならない。)
  - 3.1.6
      - オブジェクトを別の変数に入れると、片方の中身を変えたらもう片方も同じに変わる(ネストしてる部分かどうか関係なしに)
      ```js
      変数foo → 値← 変数bar
      ```
      - スプレッド構文を使ってコピーすると、`bar.num`を書き換えても`foo.num`は影響を受けない。ただ、ネストしてるところは同じオブジェクト扱いなので影響を受ける
      ```js
      // コピーするとこうなる
      foo -> { obj: ... } -> { num: 1234 }
      bar -> { obj: ... } ------------^ //num下はネストしてるのでコピーしない。同じオブジェクト
      ```
      - ネストしたオブジェクト全部コピーする方法は無い!→梅本さんいわく、そもそもネストするようなオブジェクトを避ける＆JSに限らず他の言語も同様とのこと 
- @SatoshiHaramura
    - オブジェクトのプロパティ名と変数名が同じのときは、プロパティ名のみ書く省略記法ができる
        - { name }
    - プロパティアクセスで[]を使うと、[式]のように、式を評価した文字列をアクセスできる
    - スプレッド構文は、オブジェクトをコピーしている
        - 便利だと思っていたけど、罠(ネストしたオブジェクトはコピーされない。同じオブジェクトを参照してしまう)がある
    - 参照を意識しておく
        - 変数がオブジェクトへの参照
        - プロパティが値を参照している
        

- @paru871 
    - オブジェクトリテラルは式(=の右にあるから)
    - プロパティ名のところ（コロンの左）に[式]という構文を書く。式を評価した結果の文字列がプロパティ名として用いられる。
    - プロパティアクセス構文では、`式1[ 式2 ]`という形アクセスするプロパティ名を動的に決めることもできる。式1はオブジェクトを表す式、式2はプロパティ名を表す式
    - スプレッド構文は`...式`という形の構文で、`プロパティ: 式`の代わりに使用することができる。
    - スプレッド構文を用いると、オブジェクトの作成時にプロパティを別のオブジェクトからコピーすることができる。
    - コピー後に同じプロパティ名がある場合はあとの方の値で上書きされる
    - 「オブジェクトを明示的にコピーする」とは・・・スプレッド構文を使う方法
    - ↑は「各プロパティが同じ値を持つ新しいオブジェクトを作る」ということ、ネストしたオブジェクトのコピーは注意
    - javascriptでディープコピーは`lodash`を使って行う



### 本日の振り返り(よかった点・次回に向けての改善点等)

- @cafedomancer 
    - すみません、風邪で声が出ません :mask: :odaijini: :odaijini::odaijini::odaijini:
        - コロナではなかったです
    - 次回から型の話だ :raised_hands: 
    - 細かい挙動を理解するには The TypeScript Handbook を 100 回くらい読まないとダメなんだな〜 :sob: 
        - TypeScript の公式の本？です

- @paru871 
    - 2週参加できなかったので久しぶりに見たら浦島太郎でした。やっぱりTSってJSとは少し違うんだなと思いました。急いで追いつきますね！
        - 先週ちょっとJSだけのところ飛ばしました！！！:bow:
    - Maedaさんがいなかった。。😭

- @Saki
    - 梅本さん風邪がお辛いのにご解説ありがとうございます🙏🙏🙏

- @haruguchi
    - 梅本さんが命を削って解説してくれていた。
        - 渾身の説明をいっしーさんが聞いてなかったｗ :yurusarezarumono: :moyai:
    - 来週は前田さんいます！！
    - React触るとイミュータブルってすごく意識させられる気がする。(何回も出てくる)
        - mutate できる・される可能性がある -> mutable
        - mutate できない・される可能性がない -> im-mutable
        - mutate は "変化させる"
        - Ruby の `fronzen_string_liteal` は string literal を immutable にするおまじない？宣言？ これがない場合、Ruby の string は mutable (`"a" << "b"` とかできる) 。string が mutable な言語はめずらしい気がします。
