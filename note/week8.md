# 【第8週】ブルーベリー本輪読会🫐🫐<br />(2022-07-02)

[![hackmd-github-sync-badge](https://hackmd.io/EZvPIYJ0Rjm6c2UHiIz6dA/badge)](https://hackmd.io/EZvPIYJ0Rjm6c2UHiIz6dA)


###### tags: `ブルーベリー本`

- [開催概要](https://hackmd.io/1kCgi6_tSGukG0KZrqDLvA)
- [ブルーベリー本輪読会ノートまとめ](https://hackmd.io/Ih6bdReuR3eQpYkGaCx8pg)
- [プロを目指す人のためのTypeScript入門-サポートページ](https://gihyo.jp/book/2022/978-4-297-12747-3/support)（正誤表・サンプルコードのダウンロードページ）

---
## 2022-07-02（土）

### タイムスケジュール
- 雑談(5min) ~9:05
- 輪読(40min) ~9:45
- 前半の記入(5min) ~9:50
- 休憩(10min) ~10:00
- 輪読(45min) 前半での疑問の解消含む ~10:45
- まとめ(15min) ~ 11:00

### 進行係
- 前半
    - @haramura
- 後半
    - @haruguchi
### ドライバー
- 前半
    - @paru 
- 後半
    - @mae-da 

### 読んだところ
- p.95 「3.3 部分型関係」 から p.103 「3.4.4 オプショナルな型引数」 まで

### 次回
- p.103 「3.5 配列」 から

### 自由に使う共有スペース
```typescript=
type User = {name: string; age: number};

const obj: User = {
    name: 'uhyo',
    age: 26,
    telNumber: '00000000000'
};

// 本来 objが推論されるオブジェクト型はUserの部分型なのでOKなはす！
// でもエラーが出る

// 理由は変数objはUser型である以上telNumberにプロパティアクセスできない。
// つまり、アクセスできないtelNumberというプロパティは意味がない（無駄という表現だった）
// 気を利かせてコンパイラがエラーにしてくれる
```
### わからなかったこと・疑問など

- 3.3.3の最初のコードだけエラーが発生する理由がよく分かりません...「型注釈がある変数にオブジェクトリテラルを直に代入する場合にのみ発生する」?
    - オブジェクトリテラルで定義されたオブジェクトには変数経由でしかアクセスできないので、そのオブジェクトの型がある型の部分型であっても、代入以降はつねにある型とみなされる。なのでオブジェクトリテラルで余剰プロパティを設定する意味がなくなってしまう。


- extends が使われるのは型引数に対してだけ？
```js
type Animal extends HasName = {
...
}
```
とか思ったけどこれも特に意味がない感じになるやつか笑（というか意味不明？）

- interface に extends というのがありますよ。constraint の extends とは異なるものです。
    - なるほど！調べてみます！！！継承っぽい感じ？


- オプショナルでない型引数は省略できるのか？ できるとして省略したときは何の型になるのか？ 
    - なんか推論された
        - 推論される場合もあるようだ

![](https://i.imgur.com/sWRfk6U.png)

### 各自の疑問点や気づき、学んだこと

- @Saki
  - Animal(FooBar) > human(FoorBarBaz)。haruguchiさんの図がわかりやすい。  :wara:
  - 「FooBarBazは、FooBarの部分型」とはどういうこと?
      - FooBarBazはFoorBarの一種(一部)
      - HumanはAnimalの一部 と考えると分かりやすい 
      - ということは、FooBarの中にFooBarBazがある
      - 逆にFooBarBazの中にFooBarはいない。**Bazが無いから**。
      - 日本語の「部分」という言葉に惑わされない。「部分集合」の考え方を持つ!
  - 3.3.3、まとめ
      - p.98のコードでは、User型を代入しているので、`telNumber`プロパティを設定しても、`u.telNumber`と書いてもアクセスできない。つまりここで書いても無意味なのでエラーが出る。
      - エラー内容：「オブジェクトプロパティは知っているプロパティ(nameとage)しか指定できない。telNumberはUserに存在していません」
      - p.99ではなぜエラーが出ないのか
   ```javascript
        type User = {name: string; age: number};

        const obj: = { //型注釈がない変数だから、自由にプロパティを設定できる。
        name: 'uhyo',
        age: 26,
        telNumber: '00000000000'
          }; //=>これは部分型関係。エラーは出ない。

      <!--  ここまでは、obj.telNumberで参照できる。だからエラーにならない。    -->

        const u: User = obj

      <!--  ここからは、Userの型注釈が代入されたので、u.telNumberで参照できない。    -->
   ```
   - p.100の3.4.3(制約)
       - 登場人物が3人になってややこしいが、こんなイメージ
        `HasName > Animal(Parent) > Human(Child)`
        右に行くほど制約が厳しくなる感じ。

- @haruguchi
    -  オブジェクト型Sがオブジェクト型Tの部分型である条件は
        -  TのプロパティをSが全て持っている
        -  Sが持っているプロパティの型がTが持っているプロパティの型の部分型である
    - 余剰プロパティに対する型チェックはコンパイラ賢いなぁ
    - 数学の集合で考えるとわかりやすい。
    - `T extends U`とすることでTはUの部分型である必要があるという制約をつけることができる。
    - 型引数は関数のデフォルト引数みたいに指定されなかった時のデフォルトの型を設定できる

- @mami-inuzuka 
    - 余剰プロパティに対する型チェックは、オブジェクトリテラルに直接型注釈をつけた時だけ補助的に起こる
    - p99の例は『一旦objに入れた時点でただの`{name: string, age: number, telNumber: number}`型の変数になる』という説明でだいぶしっくりきた
        - オブジェクトリテラルを変数に入れると型推論により変数に型が付けられる
        - その上で`{name: string, age: number, telNumber: number}`（型推論によりobjについた型）と`{name: string, age: number}`（User型）を比較していて前者は後者の部分型だからエラーが出ない
        

- @mae-da
	- 部分型について
	- SがTの部分型であることは、
		- 1. TのもつプロパティがSに全てあること
		- 2. Sのプロパティの型がTのプロパティの型の部分型であること
	- p.96のコードで`obj2`はFooBar型として定義されているが、`obj`を代入してもコンパイルエラーが起きないのは、FooBarBaz型はFooBar型の部分型であるため。
		- ただし、`obj2`はFooBar型であることは変わりないため、`obj2.baz`にアクセスしようとするとコンパイルエラーが発生する（`obj`を代入してるけど）
	- > 余剰プロパティのエラーは型注釈がある変数にオブジェクトリテラルを直に代入する場合にのみ発生する
		- 型注釈のない変数にオブジェクトリテラルを代入して使うことで余剰プロパティのエラーがなくなる（説明になってない...分かってないな）
	- ⇒Sakiさんの質問に対する梅本さんの説明がわかりやすかった
		- オブジェクトは変数に代入しないと参照できないことがポイントっぽい
	- ジェネリック型を学んだ
	- 部分型も型引数の方も何もまとまってない...復習します:bow:

- @paru871 
    - 部分型は共通するプロパティを持つ
        - 共通するだと正しくないですね `{ name: string, weight: number }` と `{ name: string, height: number }` が当てはまってしまう
            - たしかにそうですね！「包含する」「包含関係」を使うのがやっぱりよさそうです。 

- @cafedomancer
    - 部分型のプロパティも部分型でいいらしい。たし🦀
        > 条件1の各プロパティについて、Sにおけるそのプロパティの型はTにおけるプロパティの型の部分型(または同じ型)
である。
    - S = T でも部分型といえるのだろうか？
        > A = B と A ⊆ B かつ B ⊆ A は同値である

- @SatoshiHaramura
    - 部分型とは、ある型を特化したもののイメージ
        - 包含関係とは、を理解し直さないと...
            - 包含関係はAはBを含むか？ということですね。:naruhodo~:
            - 動物は人間を含むか？ :hukumu:
            - 三角形は正三角形を含むか？ :hukumu!!:
            - string型は'foo'を含むか？みたいな :hukumu!!:
                - バナナはおやつに入るか？ :banana: :kozin ni yorikeri??:
                - トマトは野菜に入るか？果物に入るか？ ：tomato： :tomato ha yasai ni hairu!!:
    - `型引数`を持つ型を宣言すると、その型を使用するときに`指定した型`を使える

### 本日の振り返り(よかった点・次回に向けての改善点等)

- @haruguchi
    - 部分型と型引数むずかしー！
    - でも何回もやってるうちに慣れてきた感があります（個人の感想）
    - Maedaさんに後輩ができて嬉しい！

- @Saki
    - 型引数の理解がふわっとしてます
    - チェリー本だと徐々に難易度があがるいめーじなので、「まだ3章なのに🤯」と思っていましたが、ここが一番難しいと聞いて、「あとはくだる」だけと思えました
    - 梅本さんの説明が本当にわかりやすくてありがたいです〜😭✨🙏 :kansha: :kansha: :kansha: :kansha:

- @mami-inuzuka 
    - 部分型がまだ怪しいので復習します！🙌🏻 →　英語で調べてみよう
    - だんだん難しくなってきたけどみんなで読むと一緒に疑問をクリアにできてめっちゃいいですね✨ :wakaru: :ii!!:

- @cafedomancer 
    - モリモリだ (ハデハデだの感じで)

- @mae-da 
	- 部分型もジェネリック型も難しい...
	- 十分条件と必要条件の話を思い出してしまいました :crying_cat_face: 

- @paru871 
    - 暑すぎる！部分型はまだよかったけれど型引数で頭が爆発しそうになったので、夜涼しくなったらもう一度読んでみます。 :atsui!!!!:つ🍧
    - 初(たぶん)ドライバー役は緊張しましたー！さくさく入力していろいろ試してみていたMaedaさんすごいなーと思いました。
        - Maeda パイセン！

- @SatoshiHaramura
    - 包含関係について復習しなきゃ！
        - すべての〇〇は、すべての〇〇を含むのか？
![](https://i.imgur.com/KSwIU6R.png)
